{
  "version": 3,
  "file": "grammar-utils.js",
  "sourceRoot": "..\\..\\",
  "sources": [
    "src\\lib\\grammar-utils.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "# grammar-utils.coffee\r\n\r\nimport {\r\n\tundef, defined, notdefined, OL, LOG, keys, hasKey,\r\n\tisString, isHash, isArray, isInteger, range, inRange,\r\n\tisEmpty, nonEmpty, centered, escapeStr,\r\n\tassert, croak, getOptions,\r\n\t} from '@jdeighan/llutils'\r\nimport {MultiMap} from '@jdeighan/llutils/multi-map'\r\nimport {\r\n\tterminal, nonterminal, phi,\r\n\tRuleEx, checkRule, ruleAsString,\r\n\t} from '@jdeighan/llutils/rule-ex'\r\n\r\n# ---------------------------------------------------------------------------\r\n#     class Grammar\r\n# ---------------------------------------------------------------------------\r\n\r\nexport class Grammar\r\n\r\n\tconstructor: (@hAST) ->\r\n\r\n\t\t[@setNonTerminals, @setTerminals] = checkAST @hAST\r\n\r\n\t# ..........................................................\r\n\r\n\tisTerminal: (item) ->\r\n\r\n\t\treturn @setTerminals.has item\r\n\r\n\t# ..........................................................\r\n\r\n\tisNonTerminal: (str) ->\r\n\r\n\t\treturn @setNonTerminals.has str\r\n\r\n\t# ..........................................................\r\n\r\n\troot: () ->\r\n\r\n\t\treturn @hAST.lRules[0]?.head\r\n\r\n\t# ..........................................................\r\n\r\n\tgetRule: (num) ->\r\n\r\n\t\tassert inRange(num, @hAST.lRules.length),\r\n\t\t\t\"Out of range: #{OL(num)}\"\r\n\t\treturn @hAST.lRules[num]\r\n\r\n\t# ..........................................................\r\n\t# --- yields rules\r\n\r\n\tallRules: () ->\r\n\r\n\t\tyield from @hAST.lRules\r\n\t\treturn\r\n\r\n\t# ..........................................................\r\n\t# --- yields rules\r\n\r\n\talternatives: (name) ->\r\n\r\n\t\tfor rule in @hAST.lRules.filter((rule) -> (rule.head == name))\r\n\t\t\tyield rule\r\n\t\treturn\r\n\r\n\t# ..........................................................\r\n\r\n\tasString: () ->\r\n\r\n\t\tfunc = (hRule) => ruleAsString(hRule)\r\n\t\treturn @hAST.lRules.map(func).join(\"\\n\")\r\n\r\n# ---------------------------------------------------------------------------\r\n#     class EarleyParser\r\n# ---------------------------------------------------------------------------\r\n\r\nexport class EarleyParser\r\n\r\n\tconstructor: (hAST) ->\r\n\r\n\t\t@grammar = new Grammar(hAST)\r\n\t\tassert @grammar instanceof Grammar, \"Not a grammar\"\r\n\r\n\t\t# --- Add a phi rule at start of grammar's rule list\r\n\t\trootRule = {\r\n\t\t\ttype: \"rule\"\r\n\t\t\thead: phi\r\n\t\t\tlParts: [nonterminal(@grammar.root())]\r\n\t\t\t}\r\n\t\t@lRules = [ rootRule, @grammar.allRules()...]\r\n\t\t@width = 40\r\n\r\n\t# ..........................................................\r\n\r\n\tasString: () ->\r\n\r\n\t\treturn @grammar.asString()\r\n\r\n\t# ..........................................................\r\n\r\n\taddRule: (newRule, set) ->\r\n\r\n\t\tpre = set.size\r\n\t\tset.add newRule   # won't add dups\r\n\t\treturn (set.size == pre)\r\n\r\n\t# ..........................................................\r\n\r\n\tparse: (str, hOptions={}) ->\r\n\r\n\t\t{debug, root} = getOptions hOptions, {\r\n\t\t\tdebug: false\r\n\t\t\troot: @grammar.root()\r\n\t\t\t}\r\n\t\titerator = @parse_generator str, hOptions\r\n\t\tnext = iterator.next()\r\n\t\twhile !next.done\r\n\t\t\tnext = iterator.next()\r\n\t\treturn next.value\r\n\r\n\t# ..........................................................\r\n\r\n\texpandSet: (S, i, str, hOptions={}) ->\r\n\r\n\t\tdebugger\r\n\t\t{debug} = getOptions hOptions, {\r\n\t\t\tdebug: false\r\n\t\t\t}\r\n\t\tcurSet = S[i]\r\n\t\tnextSet = S[i+1]\r\n\t\tif debug\r\n\t\t\tLOG centered(i, @width, {char: '-'})\r\n\r\n\t\tfor xRule from curSet.values()\r\n\t\t\tif debug\r\n\t\t\t\tLOG @ruleStr(xRule)\r\n\t\t\tnext = xRule.nextPart()\r\n\t\t\ttype = if defined(next) then next.type else undef\r\n\r\n\t\t\tlNewRules = []     # --- [ [rule, isDup, destSet], ... ]\r\n\t\t\t\t\t\t\t\t\t #     undef destSet means same set as src\r\n\t\t\tswitch type\r\n\r\n\t\t\t\twhen \"nonterminal\"\r\n\t\t\t\t\tfor rule from @grammar.alternatives(next.value)\r\n\t\t\t\t\t\tnewRule = RuleEx.getNew(rule, i)\r\n\t\t\t\t\t\tisDup = @addRule(newRule, curSet)\r\n\t\t\t\t\t\tlNewRules.push [newRule, isDup]\r\n\r\n\t\t\t\twhen \"terminal\"\r\n\t\t\t\t\tif (next.value == str[i]) && defined(nextSet)\r\n\t\t\t\t\t\tnewRule = xRule.getInc()\r\n\t\t\t\t\t\tisDup = @addRule(newRule, nextSet)\r\n\t\t\t\t\t\tlNewRules.push [newRule, isDup, i+1]\r\n\r\n\t\t\t\twhen undef\r\n\t\t\t\t\t{head, src} = xRule\r\n\t\t\t\t\tfor srcRule from S[src]\r\n\t\t\t\t\t\tnext = srcRule.nextPart()\r\n\t\t\t\t\t\tif defined(next) \\\r\n\t\t\t\t\t\t\t\t&& (next.type == 'nonterminal') \\\r\n\t\t\t\t\t\t\t\t&& (next.value == head)\r\n\t\t\t\t\t\t\tnewRule = srcRule.getInc()\r\n\t\t\t\t\t\t\tisDup = @addRule(newRule, curSet)\r\n\t\t\t\t\t\t\tlNewRules.push [newRule, isDup]\r\n\t\t\t\telse\r\n\t\t\t\t\tcroak \"Bad next type in RuleEx: #{OL(xRule)}\"\r\n\r\n\t\t\tif debug\r\n\t\t\t\tLOG @resultStr(lNewRules)\r\n\t\t\t\tyield @resultStr(lNewRules)\r\n\r\n\t\t# --- Dump contents of curSet\r\n\t\tif debug\r\n\t\t\tLOG @setStr(curSet, i)\r\n\t\treturn\r\n\r\n\t# ..........................................................\r\n\t# --- If debug == true, the function yields each time\r\n\t#     a new RuleEx is added or an existing RuleEx is\r\n\t#     incremented\r\n\r\n\tparse_generator: (str, hOptions={}) ->\r\n\r\n\t\tdebugger\r\n\t\tassert isString(str), \"Not a string: #{OL(str)}\"\r\n\t\t{debug, root} = getOptions hOptions, {\r\n\t\t\tdebug: false\r\n\t\t\troot: @grammar.root()\r\n\t\t\t}\r\n\r\n\t\t# --- Set the phi rule's lParts[0],\r\n\t\t#     in case caller specified an alternative root\r\n\t\t@lRules[0].lParts[0] = nonterminal(root)\r\n\r\n\t\tn = str.length\r\n\r\n\t\t# --- S is an array of sets of RuleEx objects\r\n\t\tS = []\r\n\t\tRuleEx.resetNextID()   # reset IDs for RuleEx objects\r\n\r\n\t\tfor i from range(n+1)\r\n\t\t\tif (i == 0)\r\n\t\t\t\tS.push new Set([RuleEx.getNew(@lRules[0], 0, 0)])\r\n\t\t\telse\r\n\t\t\t\tS.push new Set()\r\n\r\n\t\tlIndexes = Array.from(range(n))\r\n\t\tfor i in lIndexes\r\n\t\t\tif (S[i].size == 0)\r\n\t\t\t\tstr = escapeStr(str, {offset: i-1})\r\n\t\t\t\tthrow new SyntaxError(str)\r\n\t\t\tyield from @expandSet S, i, str, {debug}\r\n\r\n\t\tyield from @expandSet S, n, str, {debug}\r\n\t\tif debug\r\n\t\t\tLOG @setStr(S[n], n)\r\n\t\tfor xRule from S[n].values()\r\n\t\t\tif @isFinal(xRule)\r\n\t\t\t\treturn \"OK\"\r\n\t\tdebugStr = escapeStr(str, {offset: n-1})\r\n\t\tthrow new SyntaxError(debugStr)\r\n\r\n\t# ..........................................................\r\n\r\n\tisFinal: (xRule) ->\r\n\r\n\t\treturn (xRule.head == phi) && notdefined(xRule.nextPart())\r\n\r\n\t# ..........................................................\r\n\r\n\tsetStr: (set, i) ->\r\n\r\n\t\t# --- Get contents of a set as a string\r\n\t\tlLines = [centered(\"S[#{i}]\", @width, {char: '-'})]\r\n\t\tfor xRule from set\r\n\t\t\tlLines.push xRule.asString()\r\n\t\treturn lLines.join(\"\\n\")\r\n\r\n\t# ..........................................................\r\n\r\n\truleStr: (srcRuleEx) ->\r\n\r\n\t\tnext = srcRuleEx.nextPart()\r\n\t\tif defined(next)\r\n\t\t\treturn \"#{srcRuleEx.asString()} (#{next.type} next)\"\r\n\t\telse\r\n\t\t\treturn \"#{srcRuleEx.asString()} (at end)\"\r\n\r\n\t# ..........................................................\r\n\r\n\tresultStr: (lNewRules=[]) ->\r\n\r\n\t\tlLines = []\r\n\t\tfor [rule, isDup, destSet] in lNewRules\r\n\t\t\tstatus = if isDup then 'DUP ' else ''\r\n\t\t\tif defined(destSet)\r\n\t\t\t\tlLines.push \"   #{status}#{rule.asString()} ===> S#{destSet}\"\r\n\t\t\telse\r\n\t\t\t\tlLines.push \"   #{status}#{rule.asString()}\"\r\n\t\tif isEmpty(lLines)\r\n\t\t\tlLines.push \"   NO MATCH\"\r\n\t\treturn lLines.join(\"\\n\")\r\n\r\n# ---------------------------------------------------------------------------\r\n#     Utility Functions\r\n# ---------------------------------------------------------------------------\r\n# --- returns [<set of nonterminals>, <set of terminals>]\r\n#     croaks if RHS of a rule has an undefined nonterminal\r\n\r\nexport checkAST = (hAST) ->\r\n\r\n\tassert [\r\n\t\tisHash(hAST),\r\n\t\t(hAST.type == 'grammar'),\r\n\t\thasKey(hAST, 'lRules'),\r\n\t\tisArray(hAST.lRules),\r\n\t\t], \"Bad AST: #{OL(hAST)}\"\r\n\r\n\tsetNonTerminals = new Set()\r\n\tfor hRule in hAST.lRules\r\n\t\tcheckRule(hRule)\r\n\t\tsetNonTerminals.add hRule.head\r\n\r\n\tsetTerminals = new Set()\r\n\tfor hRule,i in hAST.lRules\r\n\t\tfor item,j in hRule.lParts\r\n\t\t\tassert [\r\n\t\t\t\tisHash(item),\r\n\t\t\t\thasKey(item, 'type'),\r\n\t\t\t\t], \"Bad item #{i}/#{j}: #{OL(item)}\"\r\n\t\t\tif (item.type == 'terminal')\r\n\t\t\t\tsetTerminals.add item.value\r\n\t\t\telse if (item.type == 'nonterminal')\r\n\t\t\t\tassert setNonTerminals.has item.value\r\n\t\t\telse\r\n\t\t\t\tcroak \"Bad item #{i}/#{j}: #{OL(item)}\"\r\n\treturn [setNonTerminals, setTerminals]\r\n"
  ]
}