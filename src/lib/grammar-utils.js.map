{
  "version": 3,
  "file": "grammar-utils.js",
  "sourceRoot": "..\\..\\",
  "sources": [
    "src\\lib\\grammar-utils.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "# grammar-utils.coffee\r\n\r\nimport {\r\n\tundef, defined, notdefined, OL, LOG, keys, hasKey,\r\n\tisString, isHash, isArray, isInteger, range, inRange,\r\n\tassert, croak, getOptions,\r\n\t} from '@jdeighan/llutils'\r\n\r\nraisedDot = '•'\r\n\r\n# ---------------------------------------------------------------------------\r\n#     class Grammar\r\n# ---------------------------------------------------------------------------\r\n\r\nexport class Grammar\r\n\r\n\tconstructor: (@hAST) ->\r\n\r\n\t\t[@setNonTerminals, @setTerminals] = checkAST @hAST\r\n\r\n\t# ..........................................................\r\n\r\n\tisTerminal: (item) ->\r\n\r\n\t\treturn @setTerminals.has item\r\n\r\n\t# ..........................................................\r\n\r\n\tisNonTerminal: (str) ->\r\n\r\n\t\treturn @setNonTerminals.has str\r\n\r\n\t# ..........................................................\r\n\r\n\troot: () ->\r\n\r\n\t\treturn @hAST.lRules[0]?.head\r\n\r\n\t# ..........................................................\r\n\r\n\tgetRule: (num) ->\r\n\r\n\t\tassert inRange(num, @hAST.lRules.length),\r\n\t\t\t\"Out of range: #{OL(num)}\"\r\n\t\treturn @hAST.lRules[num]\r\n\r\n\t# ..........................................................\r\n\t# --- yields rules\r\n\r\n\tallRules: () ->\r\n\r\n\t\tyield from @hAST.lRules\r\n\t\treturn\r\n\r\n\t# ..........................................................\r\n\t# --- yields rules\r\n\r\n\talternatives: (name) ->\r\n\r\n\t\tfor rule in @hAST.lRules\r\n\t\t\tif rule.head == name\r\n\t\t\t\tyield rule\r\n\t\treturn\r\n\r\n\t# ..........................................................\r\n\r\n\tasString: () ->\r\n\r\n\t\tfunc = (hRule) => ruleAsString(hRule)\r\n\t\treturn @hAST.lRules.map(func).join(\"\\n\")\r\n\r\n# ---------------------------------------------------------------------------\r\n#     class RuleEx\r\n# ---------------------------------------------------------------------------\r\n\r\nexport class RuleEx\r\n\r\n\tconstructor: (@hRule, @src) ->\r\n\r\n\t\tcheckRule(@hRule)\r\n\r\n\t\t# --- Copy fields from hRule to this object\r\n\t\t@type = @hRule.type\r\n\t\t@head = @hRule.head\r\n\t\t@lParts = @hRule.lParts\r\n\t\t@pos = 0\r\n\r\n\t\tassert isInteger(@src), \"Not an int: #{OL(@src)}\"\r\n\t\t@maxpos = @lParts.length\r\n\r\n\tnextPart: () ->\r\n\r\n\t\treturn @lParts[@pos]\r\n\r\n\tinc: () ->\r\n\r\n\t\tassert (@pos+1 <= @maxpos), \"Can't inc #{this}\"\r\n\t\t@pos += 1\r\n\t\treturn\r\n\r\n\tasString: () ->\r\n\r\n\t\treturn ruleAsString(@hRule, @pos)\r\n\r\n# ---------------------------------------------------------------------------\r\n#     class EarleyParser\r\n# ---------------------------------------------------------------------------\r\n\r\nexport class EarleyParser\r\n\r\n\tconstructor: (hAST) ->\r\n\r\n\t\t@grammar = new Grammar(hAST)\r\n\t\tassert @grammar instanceof Grammar, \"Not a grammar\"\r\n\r\n\t\t# --- Add a phi rule at start of grammar's rule list\r\n\t\trootRule = {\r\n\t\t\ttype: \"rule\"\r\n\t\t\thead: \"Φ\"\r\n\t\t\tlParts: [nonterminal(@grammar.root())]\r\n\t\t\t}\r\n\t\t@lRules = [ rootRule, @grammar.allRules()...]\r\n\r\n\t# ..........................................................\r\n\t# --- If debug == true, the function yields each time\r\n\t#     a new RuleEx is added or an existing RuleEx is\r\n\t#     incremented\r\n\r\n\tparse: (str, hOptions={}) ->\r\n\r\n\t\tassert isString(str), \"Not a string: #{OL(str)}\"\r\n\t\t{debug, root} = getOptions hOptions, {\r\n\t\t\tdebug: false\r\n\t\t\troot: @grammar.root()\r\n\t\t\t}\r\n\r\n\t\t# --- Set the phi rule's lParts[0],\r\n\t\t#     in case caller specified an alternative root\r\n\t\t@lRules[0].lParts[0] = nonterminal(root)\r\n\r\n\t\tn = str.length\r\n\r\n\t\t# --- S is an array of sets of RuleEx objects\r\n\t\tS = []\r\n\t\tinitRuleEx = new RuleEx(@lRules[0], 0)\r\n\t\tfor i in range(n)\r\n\t\t\tif (i == 0)\r\n\t\t\t\tS.push new Set(initRuleEx)\r\n\t\t\telse\r\n\t\t\t\tS.push new Set()\r\n\t\tif debug\r\n\t\t\tyield initRuleEx.asString()\r\n\t\tfor i in range(n)\r\n\t\t\tset = S[i]\r\n\t\t\tassert [\r\n\t\t\t\tdefined(set),\r\n\t\t\t\t(set instanceof Set),\r\n\t\t\t\t(set.size > 0),\r\n\t\t\t\t], \"Bad set #{i}: #{OL(set)}\"\r\n\t\t\tfor xRule from S[i].values()\r\n\t\t\t\t{head} = xRule\r\n\t\t\t\tnext = xRule.nextPart()\r\n\t\t\t\tswitch next.type\r\n\t\t\t\t\twhen \"nonterminal\"\r\n\t\t\t\t\t\tfor rule from grammar.alternatives(head)\r\n\t\t\t\t\t\t\tS[i].add new RuleEx(rule, i)\r\n\t\t\t\t\twhen \"terminal\"\r\n\t\t\t\t\t\tif (next.value == str[i])\r\n\t\t\t\t\t\t\tS[i+1].add xRule.inc()\r\n\t\t\t\t\twhen undef\r\n\t\t\t\t\t\t{head, src} = xRule\r\n\t\t\t\t\t\tfor xRuleFromSrc from S[src]\r\n\t\t\t\t\t\t\thPart = xRuleFromSrc.nextPart()\r\n\t\t\t\t\t\t\tif (hPart.type == 'nonterminal') \\\r\n\t\t\t\t\t\t\t\t\t&& (hPart.value == head)\r\n\t\t\t\t\t\t\t\tS[i].add xRule.inc()\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tcroak \"Bad next type: #{OL(next)}\"\r\n\r\n\t\treturn\r\n\r\n# ---------------------------------------------------------------------------\r\n#     Utility Functions\r\n# ---------------------------------------------------------------------------\r\n\r\nexport ruleAsString = (hRule, pos=undef) ->\r\n\r\n\tlRHS = hRule.lParts.map(\r\n\t\t(hPart) =>\r\n\t\t\tswitch hPart.type\r\n\t\t\t\twhen \"terminal\"\r\n\t\t\t\t\treturn \"\\\"#{hPart.value}\\\"\"\r\n\t\t\t\twhen \"nonterminal\"\r\n\t\t\t\t\treturn \"#{hPart.value}\"\r\n\t\t)\r\n\tif defined(pos)\r\n\t\tlRHS.splice pos, 0, raisedDot\r\n\trhs = lRHS.join(\" \")\r\n\treturn \"#{hRule.head} -> #{rhs}\"\r\n\r\n# ---------------------------------------------------------------------------\r\n\r\nexport terminal = (value) ->\r\n\r\n\tassert [\r\n\t\tisString(value),\r\n\t\t(value.length == 1),\r\n\t\t], \"Bad terminal: #{OL(value)}\"\r\n\treturn {\r\n\t\ttype: 'terminal'\r\n\t\tvalue\r\n\t\t}\r\n\r\n# ---------------------------------------------------------------------------\r\n\r\nexport nonterminal = (name) ->\r\n\r\n\tassert isString(name), \"bad nonterminal: #{OL(name)}\"\r\n\treturn {\r\n\t\ttype: 'nonterminal'\r\n\t\tvalue: name\r\n\t\t}\r\n\r\n# ---------------------------------------------------------------------------\r\n# --- returns [<set of nonterminals>, <set of terminals>]\r\n#     croaks if RHS of a rule has an undefined nonterminal\r\n\r\nexport checkAST = (hAST) ->\r\n\r\n\tassert [\r\n\t\tisHash(hAST),\r\n\t\t(hAST.type == 'grammar'),\r\n\t\thasKey(hAST, 'lRules'),\r\n\t\tisArray(hAST.lRules),\r\n\t\t], \"Bad AST: #{OL(hAST)}\"\r\n\r\n\tsetNonTerminals = new Set()\r\n\tfor hRule in hAST.lRules\r\n\t\tcheckRule(hRule)\r\n\t\tsetNonTerminals.add hRule.head\r\n\r\n\tsetTerminals = new Set()\r\n\tfor hRule,i in hAST.lRules\r\n\t\tfor item,j in hRule.lParts\r\n\t\t\tassert [\r\n\t\t\t\tisHash(item),\r\n\t\t\t\thasKey(item, 'type'),\r\n\t\t\t\t], \"Bad item #{i}/#{j}: #{OL(item)}\"\r\n\t\t\tif (item.type == 'terminal')\r\n\t\t\t\tsetTerminals.add item.value\r\n\t\t\telse if (item.type == 'nonterminal')\r\n\t\t\t\tassert setNonTerminals.has item.value\r\n\t\t\telse\r\n\t\t\t\tcroak \"Bad item #{i}/#{j}: #{OL(item)}\"\r\n\treturn [setNonTerminals, setTerminals]\r\n\r\n# ---------------------------------------------------------------------------\r\n\r\nexport checkRule = (hRule) ->\r\n\r\n\tassert [\r\n\t\t(hRule.type == \"rule\"),\r\n\t\thasKey(hRule, 'head'),\r\n\t\tisString(hRule.head),\r\n\t\t(hRule.head != 'Φ'),\r\n\t\thasKey(hRule, 'lParts'),\r\n\t\tisArray(hRule.lParts),\r\n\t\t], \"Bad rule: #{OL(hRule)}\"\r\n\treturn\r\n\r\n"
  ]
}