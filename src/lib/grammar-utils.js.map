{
  "version": 3,
  "file": "grammar-utils.js",
  "sourceRoot": "..\\..\\",
  "sources": [
    "src\\lib\\grammar-utils.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "# grammar-utils.coffee\r\n\r\nimport {\r\n\tundef, defined, notdefined, OL, LOG, keys, hasKey,\r\n\tisString, isHash, isArray, isInteger, range, inRange,\r\n\tisEmpty, nonEmpty, centered,\r\n\tassert, croak, getOptions,\r\n\t} from '@jdeighan/llutils'\r\nimport {MultiMap} from '@jdeighan/llutils/multi-map'\r\nimport {\r\n\tterminal, nonterminal, phi,\r\n\tRuleEx, checkRule, ruleAsString,\r\n\t} from '@jdeighan/llutils/rule-ex'\r\n\r\n# ---------------------------------------------------------------------------\r\n#     class Grammar\r\n# ---------------------------------------------------------------------------\r\n\r\nexport class Grammar\r\n\r\n\tconstructor: (@hAST) ->\r\n\r\n\t\t[@setNonTerminals, @setTerminals] = checkAST @hAST\r\n\r\n\t# ..........................................................\r\n\r\n\tisTerminal: (item) ->\r\n\r\n\t\treturn @setTerminals.has item\r\n\r\n\t# ..........................................................\r\n\r\n\tisNonTerminal: (str) ->\r\n\r\n\t\treturn @setNonTerminals.has str\r\n\r\n\t# ..........................................................\r\n\r\n\troot: () ->\r\n\r\n\t\treturn @hAST.lRules[0]?.head\r\n\r\n\t# ..........................................................\r\n\r\n\tgetRule: (num) ->\r\n\r\n\t\tassert inRange(num, @hAST.lRules.length),\r\n\t\t\t\"Out of range: #{OL(num)}\"\r\n\t\treturn @hAST.lRules[num]\r\n\r\n\t# ..........................................................\r\n\t# --- yields rules\r\n\r\n\tallRules: () ->\r\n\r\n\t\tyield from @hAST.lRules\r\n\t\treturn\r\n\r\n\t# ..........................................................\r\n\t# --- yields rules\r\n\r\n\talternatives: (name) ->\r\n\r\n\t\tfor rule in @hAST.lRules.filter((rule) -> (rule.head == name))\r\n\t\t\tyield rule\r\n\t\treturn\r\n\r\n\t# ..........................................................\r\n\r\n\tasString: () ->\r\n\r\n\t\tfunc = (hRule) => ruleAsString(hRule)\r\n\t\treturn @hAST.lRules.map(func).join(\"\\n\")\r\n\r\n# ---------------------------------------------------------------------------\r\n#     class EarleyParser\r\n# ---------------------------------------------------------------------------\r\n\r\nexport class EarleyParser\r\n\r\n\tconstructor: (hAST) ->\r\n\r\n\t\t@grammar = new Grammar(hAST)\r\n\t\tassert @grammar instanceof Grammar, \"Not a grammar\"\r\n\r\n\t\t# --- Add a phi rule at start of grammar's rule list\r\n\t\trootRule = {\r\n\t\t\ttype: \"rule\"\r\n\t\t\thead: phi\r\n\t\t\tlParts: [nonterminal(@grammar.root())]\r\n\t\t\t}\r\n\t\t@lRules = [ rootRule, @grammar.allRules()...]\r\n\r\n\t# ..........................................................\r\n\r\n\tasString: () ->\r\n\r\n\t\treturn @grammar.asString()\r\n\r\n\t# ..........................................................\r\n\r\n\taddRule: (newRule, set) ->\r\n\r\n\t\tpre = set.size\r\n\t\tset.add newRule   # won't add dups\r\n\t\treturn (set.size == pre)\r\n\r\n\t# ..........................................................\r\n\t# --- If debug == true, the function yields each time\r\n\t#     a new RuleEx is added or an existing RuleEx is\r\n\t#     incremented\r\n\r\n\tparse: (str, hOptions={}) ->\r\n\r\n\t\tdebugger\r\n\t\tassert isString(str), \"Not a string: #{OL(str)}\"\r\n\t\t{debug, root} = getOptions hOptions, {\r\n\t\t\tdebug: false\r\n\t\t\troot: @grammar.root()\r\n\t\t\t}\r\n\r\n\t\t# --- Set the phi rule's lParts[0],\r\n\t\t#     in case caller specified an alternative root\r\n\t\t@lRules[0].lParts[0] = nonterminal(root)\r\n\r\n\t\tn = str.length\r\n\r\n\t\t# --- S is an array of sets of RuleEx objects\r\n\t\tRuleEx.resetNextID()   # reset IDs for RuleEx objects\r\n\r\n\t\tS = []\r\n\t\tinitRuleEx = RuleEx.getNew(@lRules[0], 0, 0)\r\n\t\tfor i from range(n)\r\n\t\t\tset = new Set()\r\n\t\t\tif (i == 0)\r\n\t\t\t\tset.add initRuleEx\r\n\t\t\tS.push set\r\n\t\tS.push new Set()    # --- eliminates need for a check\r\n\r\n\t\tif debug\r\n\t\t\tyield \"START:\\n\" + @resultStr([[initRuleEx, '']])\r\n\r\n\t\tfor i from range(n)\r\n\t\t\tset = S[i]\r\n\t\t\tassert (set.size > 0),\r\n\t\t\t\t\tnew SyntaxError(\"Unexpected EOS: #{escapeStr(str)}\")\r\n\r\n\t\t\tif debug\r\n\t\t\t\tLOG centered(i, 32, {char: '-'})\r\n\r\n\t\t\tfor xRule from S[i].values()\r\n\t\t\t\tif debug\r\n\t\t\t\t\tLOG @ruleStr(xRule)\r\n\t\t\t\tnext = xRule.nextPart()\r\n\t\t\t\ttype = if defined(next) then next.type else undef\r\n\r\n\t\t\t\tlNewRules = []     # --- [ [rule, isDup, destSet], ... ]\r\n\t\t\t\t                   #     undef destSet means same set as src\r\n\t\t\t\tswitch type\r\n\r\n\t\t\t\t\twhen \"nonterminal\"\r\n\t\t\t\t\t\tfor rule from @grammar.alternatives(next.value)\r\n\t\t\t\t\t\t\tnewRule = RuleEx.getNew(rule, i)\r\n\t\t\t\t\t\t\tisDup = @addRule(newRule, S[i])\r\n\t\t\t\t\t\t\tlNewRules.push [newRule, isDup]\r\n\r\n\t\t\t\t\twhen \"terminal\"\r\n\t\t\t\t\t\tif (next.value == str[i])\r\n#\t\t\t\t\t\t\tnewRule = RuleEx.getNew(xRule, i, xRule.pos+1)\r\n\t\t\t\t\t\t\tnewRule = xRule.getInc()\r\n\t\t\t\t\t\t\tisDup = @addRule(newRule, S[i+1])\r\n\t\t\t\t\t\t\tlNewRules.push [newRule, isDup, i+1]\r\n\r\n\t\t\t\t\twhen undef\r\n\t\t\t\t\t\t{head, src} = xRule\r\n\t\t\t\t\t\tfor srcRule from S[src]\r\n\t\t\t\t\t\t\tnext = srcRule.nextPart()\r\n\t\t\t\t\t\t\tif defined(next) \\\r\n\t\t\t\t\t\t\t\t\t&& (next.type == 'nonterminal') \\\r\n\t\t\t\t\t\t\t\t\t&& (next.value == head)\r\n\t\t\t\t\t\t\t\tnewRule = srcRule.getInc()\r\n\t\t\t\t\t\t\t\tisDup = @addRule(newRule, S[i])\r\n\t\t\t\t\t\t\t\tlNewRules.push [newRule, isDup]\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tcroak \"Bad next type in RuleEx: #{OL(xRule)}\"\r\n\r\n\t\t\t\tif debug\r\n\t\t\t\t\tyield @resultStr(lNewRules)\r\n\r\n\t\tLOG \"SUCCESS!\"\r\n\t\treturn \"SUCCESS\"\r\n\r\n\t# ..........................................................\r\n\r\n\truleStr: (srcRuleEx) ->\r\n\r\n\t\tnext = srcRuleEx.nextPart()\r\n\t\tif defined(next)\r\n\t\t\treturn \"#{srcRuleEx.asString()} (#{next.type} next)\"\r\n\t\telse\r\n\t\t\treturn \"#{srcRuleEx.asString()} (at end)\"\r\n\r\n\t# ..........................................................\r\n\r\n\tresultStr: (lNewRules=[]) ->\r\n\r\n\t\tlLines = []\r\n\t\tfor [rule, isDup, destSet] in lNewRules\r\n\t\t\tstatus = if isDup then 'DUP ' else ''\r\n\t\t\tif defined(destSet)\r\n\t\t\t\tlLines.push \"   #{status}#{rule.asString()} ===> S#{destSet}\"\r\n\t\t\telse\r\n\t\t\t\tlLines.push \"   #{status}#{rule.asString()}\"\r\n\t\tif isEmpty(lLines)\r\n\t\t\tlLines.push \"   NO MATCH\"\r\n\t\treturn lLines.join(\"\\n\")\r\n\r\n# ---------------------------------------------------------------------------\r\n#     Utility Functions\r\n# ---------------------------------------------------------------------------\r\n# --- returns [<set of nonterminals>, <set of terminals>]\r\n#     croaks if RHS of a rule has an undefined nonterminal\r\n\r\nexport checkAST = (hAST) ->\r\n\r\n\tassert [\r\n\t\tisHash(hAST),\r\n\t\t(hAST.type == 'grammar'),\r\n\t\thasKey(hAST, 'lRules'),\r\n\t\tisArray(hAST.lRules),\r\n\t\t], \"Bad AST: #{OL(hAST)}\"\r\n\r\n\tsetNonTerminals = new Set()\r\n\tfor hRule in hAST.lRules\r\n\t\tcheckRule(hRule)\r\n\t\tsetNonTerminals.add hRule.head\r\n\r\n\tsetTerminals = new Set()\r\n\tfor hRule,i in hAST.lRules\r\n\t\tfor item,j in hRule.lParts\r\n\t\t\tassert [\r\n\t\t\t\tisHash(item),\r\n\t\t\t\thasKey(item, 'type'),\r\n\t\t\t\t], \"Bad item #{i}/#{j}: #{OL(item)}\"\r\n\t\t\tif (item.type == 'terminal')\r\n\t\t\t\tsetTerminals.add item.value\r\n\t\t\telse if (item.type == 'nonterminal')\r\n\t\t\t\tassert setNonTerminals.has item.value\r\n\t\t\telse\r\n\t\t\t\tcroak \"Bad item #{i}/#{j}: #{OL(item)}\"\r\n\treturn [setNonTerminals, setTerminals]\r\n"
  ]
}