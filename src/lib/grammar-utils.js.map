{
  "version": 3,
  "file": "grammar-utils.js",
  "sourceRoot": "..\\..\\",
  "sources": [
    "src\\lib\\grammar-utils.coffee"
  ],
  "names": [],
  "mappings": "AAAsB;AAEtB,OAAA;EACC,KADD;EACQ,OADR;EACiB,UADjB;EAC6B,EAD7B;EACiC,GADjC;EACsC,IADtC;EAC4C,MAD5C;EAEC,QAFD;EAEW,MAFX;EAEmB,OAFnB;EAE4B,SAF5B;EAEuC,KAFvC;EAE8C,OAF9C;EAGC,OAHD;EAGU,QAHV;EAGoB,QAHpB;EAIC,MAJD;EAIS,KAJT;EAIgB,UAJhB;CAAA,MAAA;;AAMA,OAAA;EAAQ,QAAR;CAAA,MAAA;;AACA,OAAA;EACC,QADD;EACW,WADX;EAEC,MAFD;EAES,SAFT;EAEoB,YAFpB;CAAA,MAAA,4BATsB;;;;;AAkBtB,OAAA,IAAa,UAAN,MAAA,QAAA;EAEN,WAAa,MAAA,CAAA;IAAC,IAAC,CAAA;IAEd,CAAC,IAAC,CAAA,eAAF,EAAmB,IAAC,CAAA,YAApB,CAAA,GAAoC,QAAA,CAAS,IAAC,CAAA,IAAV;EAFxB,CAAd;;;EAMC,UAAY,CAAC,IAAD,CAAA;AAEX,WAAO,IAAC,CAAA,YAAY,CAAC,GAAd,CAAkB,IAAlB;EAFI,CANb;;;EAYC,aAAe,CAAC,GAAD,CAAA;AAEd,WAAO,IAAC,CAAA,eAAe,CAAC,GAAjB,CAAqB,GAArB;EAFO,CAZhB;;;EAkBC,IAAM,CAAA,CAAA;AAEP,QAAA;AAAE,oDAAsB,CAAE;EAFnB,CAlBP;;;EAwBC,OAAS,CAAC,GAAD,CAAA;IAER,MAAA,CAAO,OAAA,CAAQ,GAAR,EAAa,IAAC,CAAA,IAAI,CAAC,MAAM,CAAC,MAA1B,CAAP,EACC,CAAA,cAAA,CAAA,CAAiB,EAAA,CAAG,GAAH,CAAjB,CAAA,CADD;AAEA,WAAO,IAAC,CAAA,IAAI,CAAC,MAAM,CAAC,GAAD;EAJX,CAxBV;;;;EAiCW,EAAV,QAAU,CAAA,CAAA;IAET,OAAW,IAAC,CAAA,IAAI,CAAC;EAFR,CAjCX;;;;EAyCe,EAAd,YAAc,CAAC,IAAD,CAAA;AAEf,QAAA,CAAA,EAAA,GAAA,EAAA,GAAA,EAAA;AAAE;;;IAAA,KAAA,qCAAA;;MACC,MAAM;IADP;EAFa,CAzCf;;;EAiDC,QAAU,CAAA,CAAA;AAEX,QAAA;IAAE,IAAA,GAAO,CAAC,KAAD,CAAA,GAAA;aAAW,YAAA,CAAa,KAAb;IAAX;AACP,WAAO,IAAC,CAAA,IAAI,CAAC,MAAM,CAAC,GAAb,CAAiB,IAAjB,CAAsB,CAAC,IAAvB,CAA4B,IAA5B;EAHE;;AAnDJ,EAlBe;;;;;AA8EtB,OAAA,IAAa,eAAN,MAAA,aAAA;EAEN,WAAa,CAAC,IAAD,CAAA;AAEd,QAAA;IAAE,IAAC,CAAA,OAAD,GAAW,IAAI,OAAJ,CAAY,IAAZ;IACX,MAAA,CAAO,IAAC,CAAA,OAAD,YAAoB,OAA3B,EAAoC,eAApC,EADF;;IAIE,QAAA,GAAW;MACV,IAAA,EAAM,MADI;MAEV,IAAA,EAAM,GAFI;MAGV,MAAA,EAAQ,CAAC,WAAA,CAAY,IAAC,CAAA,OAAO,CAAC,IAAT,CAAA,CAAZ,CAAD;IAHE;IAKX,IAAC,CAAA,MAAD,GAAU,CAAE,QAAF,EAAY,GAAA,IAAC,CAAA,OAAO,CAAC,QAAT,CAAA,CAAZ;EAXE,CAAd;;;EAeC,QAAU,CAAA,CAAA;AAET,WAAO,IAAC,CAAA,OAAO,CAAC,QAAT,CAAA;EAFE,CAfX;;;;;;EAwBQ,EAAP,KAAO,CAAC,GAAD,EAAM,WAAS,CAAA,CAAf,CAAA;AAEN;AAAF,QAAA,CAAA,EAAA,KAAA,EAAA,KAAA,EAAA,IAAA,EAAA,CAAA,EAAA,UAAA,EAAA,KAAA,EAAA,SAAA,EAAA,SAAA,EAAA,CAAA,EAAA,OAAA,EAAA,IAAA,EAAA,GAAA,EAAA,GAAA,EAAA,IAAA,EAAA,IAAA,EAAA,IAAA,EAAA,IAAA,EAAA,IAAA,EAAA,IAAA,EAAA,GAAA,EAAA,GAAA,EAAA,KAAA,EAAA;IACE,MAAA,CAAO,QAAA,CAAS,GAAT,CAAP,EAAsB,CAAA,cAAA,CAAA,CAAiB,EAAA,CAAG,GAAH,CAAjB,CAAA,CAAtB;IACA,CAAA,CAAC,KAAD,EAAQ,IAAR,CAAA,GAAgB,UAAA,CAAW,QAAX,EAAqB;MACpC,KAAA,EAAO,KAD6B;MAEpC,IAAA,EAAM,IAAC,CAAA,OAAO,CAAC,IAAT,CAAA;IAF8B,CAArB,CAAhB,EAFF;;;IASE,IAAC,CAAA,MAAM,CAAC,CAAD,CAAG,CAAC,MAAM,CAAC,CAAD,CAAjB,GAAuB,WAAA,CAAY,IAAZ;IAEvB,CAAA,GAAI,GAAG,CAAC,OAXV;;IAcE,MAAM,CAAC,WAAP,CAAA,EAdF;IAgBE,CAAA,GAAI;IACJ,UAAA,GAAa,MAAM,CAAC,GAAP,CAAW,IAAC,CAAA,MAAM,CAAC,CAAD,CAAlB,EAAuB,CAAvB,EAA0B,CAA1B;AACb;IAAA,KAAA,QAAA;MACC,GAAA,GAAM,IAAI,GAAJ,CAAA;MACN,IAAI,CAAA,KAAK,CAAT;QACC,GAAG,CAAC,GAAJ,CAAQ,UAAR,EADD;;MAEA,CAAC,CAAC,IAAF,CAAO,GAAP;IAJD;IAMA,IAAG,KAAH;MACC,MAAM,UAAA,GAAa,IAAC,CAAA,QAAD,CAAU,KAAV,EAAiB,CAAC,UAAD,CAAjB,EADpB;;AAGA;IAAA,KAAA,SAAA;MACC,GAAA,GAAM,CAAC,CAAC,CAAD;MACP,MAAA,CAAO,CACN,OAAA,CAAQ,GAAR,CADM,EAEL,GAAA,YAAe,GAFV,EAGL,GAAG,CAAC,IAAJ,GAAW,CAHN,CAAP,EAII,CAAA,QAAA,CAAA,CAAW,CAAX,CAAA,EAAA,CAAA,CAAiB,EAAA,CAAG,GAAH,CAAjB,CAAA,CAJJ;MAMA,IAAG,KAAH;QACC,GAAA,CAAI,QAAA,CAAS,CAAT,EAAY,EAAZ,EAAgB;UAAC,IAAA,EAAM;QAAP,CAAhB,CAAJ,EADD;;AAGA;MAAA,KAAA,aAAA;QACC,IAAA,GAAO,KAAK,CAAC,QAAN,CAAA;AACP,gBAAO,IAAI,CAAC,IAAZ;AAAA,eACM,aADN;YAEE,SAAA,GAAY;YACZ,SAAA,GAAY;AACZ;YAAA,KAAA,YAAA;cACC,OAAA,GAAU,MAAM,CAAC,GAAP,CAAW,IAAX,EAAiB,CAAjB,EAAoB,CAApB;cACV,GAAA,GAAM,CAAC,CAAC,CAAD,CAAG,CAAC;cACX,CAAC,CAAC,CAAD,CAAG,CAAC,GAAL,CAAS,OAAT,EAFP;cAGO,KAAA,GAAS,CAAC,CAAC,CAAD,CAAG,CAAC,IAAL,KAAa;cACtB,IAAG,KAAH;gBACC,SAAS,CAAC,IAAV,CAAe,OAAf,EADD;eAAA,MAAA;gBAGC,SAAS,CAAC,IAAV,CAAe,OAAf,EAHD;;YALD;YASA,IAAG,KAAH;cACC,MAAM,IAAC,CAAA,QAAD,CAAU,KAAV,EAAiB,SAAjB,EAA4B,SAA5B,EADP;;AAZI;AADN,eAeM,UAfN;YAgBE,IAAI,IAAI,CAAC,KAAL,KAAc,GAAG,CAAC,CAAD,CAArB;cACC,OAAA,GAAU,MAAM,CAAC,GAAP,CAAW,IAAX,EAAiB,CAAjB,EAAoB,KAAK,CAAC,GAAN,GAAU,CAA9B;cACV,GAAA,GAAM,CAAC,CAAC,CAAD,CAAG,CAAC;cACX,CAAC,CAAC,CAAA,GAAE,CAAH,CAAK,CAAC,GAAP,CAAW,KAAK,CAAC,MAAN,CAAA,CAAX;cACA,KAAA,GAAS,CAAC,CAAC,CAAD,CAAG,CAAC,IAAL,KAAa;cACtB,IAAG,KAAH;gBACC,SAAS,CAAC,IAAV,CAAe,OAAf,EADD;eAAA,MAAA;gBAGC,SAAS,CAAC,IAAV,CAAe,OAAf,EAHD;;cAIA,MAAM,IAAC,CAAA,QAAD,CAAU,KAAV,EAAiB,SAAjB,EAA4B,SAA5B,EATP;aAAA,MAAA;cAWC,MAAM,IAAC,CAAA,QAAD,CAAU,KAAV,EAAiB,SAAjB,EAXP;;AADI;AAfN,eA4BM,KA5BN;YA6BE,CAAA,CAAC,IAAD,EAAO,GAAP,CAAA,GAAc,KAAd;AACA;YAAA,KAAA,oBAAA;cACC,KAAA,GAAQ,YAAY,CAAC,QAAb,CAAA;cACR,IAAG,CAAC,KAAK,CAAC,IAAN,KAAc,aAAf,CAAA,IACE,CAAC,KAAK,CAAC,KAAN,KAAe,IAAhB,CADL;gBAEC,CAAC,CAAC,CAAD,CAAG,CAAC,GAAL,CAAS,KAAK,CAAC,MAAN,CAAA,CAAT,EAFD;;YAFD;AAFI;AA5BN;YAoCE,KAAA,CAAM,CAAA,eAAA,CAAA,CAAkB,EAAA,CAAG,IAAH,CAAlB,CAAA,CAAN;AApCF;MAFD;IAXD;EA7BM,CAxBR;;;EA4GC,QAAU,CAAC,OAAD,EAAU,YAAU,EAApB,EAAwB,YAAU,EAAlC,CAAA;AAEX,QAAA,CAAA,EAAA,CAAA,EAAA,MAAA,EAAA,GAAA,EAAA,IAAA,EAAA;IAAE,IAAG,OAAA,CAAQ,OAAR,CAAH;MACC,MAAA,GAAS,CAAC,OAAO,CAAC,QAAR,CAAA,CAAD,EADV;KAAA,MAAA;MAGC,MAAA,GAAS,GAHV;;IAKA,KAAA,2CAAA;;MACC,MAAM,CAAC,IAAP,CAAY,IAAA,CAAA,CAAM,IAAI,CAAC,QAAL,CAAA,CAAN,CAAA,CAAZ;IADD;IAEA,KAAA,6CAAA;;MACC,MAAM,CAAC,IAAP,CAAY,IAAA,CAAA,CAAM,IAAI,CAAC,QAAL,CAAA,CAAN,CAAA,MAAA,CAAZ;IADD;AAEA,WAAO,MAAM,CAAC,IAAP,CAAY,IAAZ;EAXE;;AA9GJ,EA9Ee;;;;;;;AA+MtB,OAAA,IAAO,QAAA,GAAW,QAAA,CAAC,IAAD,CAAA;AAElB,MAAA,KAAA,EAAA,CAAA,EAAA,IAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,GAAA,EAAA,IAAA,EAAA,IAAA,EAAA,CAAA,EAAA,GAAA,EAAA,IAAA,EAAA,IAAA,EAAA,eAAA,EAAA;EAAC,MAAA,CAAO,CACN,MAAA,CAAO,IAAP,CADM,EAEL,IAAI,CAAC,IAAL,KAAa,SAFR,EAGN,MAAA,CAAO,IAAP,EAAa,QAAb,CAHM,EAIN,OAAA,CAAQ,IAAI,CAAC,MAAb,CAJM,CAAP,EAKI,CAAA,SAAA,CAAA,CAAY,EAAA,CAAG,IAAH,CAAZ,CAAA,CALJ;EAOA,eAAA,GAAkB,IAAI,GAAJ,CAAA;AAClB;EAAA,KAAA,qCAAA;;IACC,SAAA,CAAU,KAAV;IACA,eAAe,CAAC,GAAhB,CAAoB,KAAK,CAAC,IAA1B;EAFD;EAIA,YAAA,GAAe,IAAI,GAAJ,CAAA;AACf;EAAA,KAAA,gDAAA;;AACC;IAAA,KAAA,gDAAA;;MACC,MAAA,CAAO,CACN,MAAA,CAAO,IAAP,CADM,EAEN,MAAA,CAAO,IAAP,EAAa,MAAb,CAFM,CAAP,EAGI,CAAA,SAAA,CAAA,CAAY,CAAZ,CAAA,CAAA,CAAA,CAAiB,CAAjB,CAAA,EAAA,CAAA,CAAuB,EAAA,CAAG,IAAH,CAAvB,CAAA,CAHJ;MAIA,IAAI,IAAI,CAAC,IAAL,KAAa,UAAjB;QACC,YAAY,CAAC,GAAb,CAAiB,IAAI,CAAC,KAAtB,EADD;OAAA,MAEK,IAAI,IAAI,CAAC,IAAL,KAAa,aAAjB;QACJ,MAAA,CAAO,eAAe,CAAC,GAAhB,CAAoB,IAAI,CAAC,KAAzB,CAAP,EADI;OAAA,MAAA;QAGJ,KAAA,CAAM,CAAA,SAAA,CAAA,CAAY,CAAZ,CAAA,CAAA,CAAA,CAAiB,CAAjB,CAAA,EAAA,CAAA,CAAuB,EAAA,CAAG,IAAH,CAAvB,CAAA,CAAN,EAHI;;IAPN;EADD;AAYA,SAAO,CAAC,eAAD,EAAkB,YAAlB;AA3BU",
  "sourcesContent": [
    "# grammar-utils.coffee\r\n\r\nimport {\r\n\tundef, defined, notdefined, OL, LOG, keys, hasKey,\r\n\tisString, isHash, isArray, isInteger, range, inRange,\r\n\tisEmpty, nonEmpty, centered,\r\n\tassert, croak, getOptions,\r\n\t} from '@jdeighan/llutils'\r\nimport {MultiMap} from '@jdeighan/llutils/multi-map'\r\nimport {\r\n\tterminal, nonterminal,\r\n\tRuleEx, checkRule, ruleAsString,\r\n\t} from '@jdeighan/llutils/rule-ex'\r\n\r\n# ---------------------------------------------------------------------------\r\n#     class Grammar\r\n# ---------------------------------------------------------------------------\r\n\r\nexport class Grammar\r\n\r\n\tconstructor: (@hAST) ->\r\n\r\n\t\t[@setNonTerminals, @setTerminals] = checkAST @hAST\r\n\r\n\t# ..........................................................\r\n\r\n\tisTerminal: (item) ->\r\n\r\n\t\treturn @setTerminals.has item\r\n\r\n\t# ..........................................................\r\n\r\n\tisNonTerminal: (str) ->\r\n\r\n\t\treturn @setNonTerminals.has str\r\n\r\n\t# ..........................................................\r\n\r\n\troot: () ->\r\n\r\n\t\treturn @hAST.lRules[0]?.head\r\n\r\n\t# ..........................................................\r\n\r\n\tgetRule: (num) ->\r\n\r\n\t\tassert inRange(num, @hAST.lRules.length),\r\n\t\t\t\"Out of range: #{OL(num)}\"\r\n\t\treturn @hAST.lRules[num]\r\n\r\n\t# ..........................................................\r\n\t# --- yields rules\r\n\r\n\tallRules: () ->\r\n\r\n\t\tyield from @hAST.lRules\r\n\t\treturn\r\n\r\n\t# ..........................................................\r\n\t# --- yields rules\r\n\r\n\talternatives: (name) ->\r\n\r\n\t\tfor rule in @hAST.lRules.filter((rule) -> (rule.head == name))\r\n\t\t\tyield rule\r\n\t\treturn\r\n\r\n\t# ..........................................................\r\n\r\n\tasString: () ->\r\n\r\n\t\tfunc = (hRule) => ruleAsString(hRule)\r\n\t\treturn @hAST.lRules.map(func).join(\"\\n\")\r\n\r\n# ---------------------------------------------------------------------------\r\n#     class EarleyParser\r\n# ---------------------------------------------------------------------------\r\n\r\nexport class EarleyParser\r\n\r\n\tconstructor: (hAST) ->\r\n\r\n\t\t@grammar = new Grammar(hAST)\r\n\t\tassert @grammar instanceof Grammar, \"Not a grammar\"\r\n\r\n\t\t# --- Add a phi rule at start of grammar's rule list\r\n\t\trootRule = {\r\n\t\t\ttype: \"rule\"\r\n\t\t\thead: \"Î¦\"\r\n\t\t\tlParts: [nonterminal(@grammar.root())]\r\n\t\t\t}\r\n\t\t@lRules = [ rootRule, @grammar.allRules()...]\r\n\r\n\t# ..........................................................\r\n\r\n\tasString: () ->\r\n\r\n\t\treturn @grammar.asString()\r\n\r\n\t# ..........................................................\r\n\t# --- If debug == true, the function yields each time\r\n\t#     a new RuleEx is added or an existing RuleEx is\r\n\t#     incremented\r\n\r\n\tparse: (str, hOptions={}) ->\r\n\r\n\t\tdebugger\r\n\t\tassert isString(str), \"Not a string: #{OL(str)}\"\r\n\t\t{debug, root} = getOptions hOptions, {\r\n\t\t\tdebug: false\r\n\t\t\troot: @grammar.root()\r\n\t\t\t}\r\n\r\n\t\t# --- Set the phi rule's lParts[0],\r\n\t\t#     in case caller specified an alternative root\r\n\t\t@lRules[0].lParts[0] = nonterminal(root)\r\n\r\n\t\tn = str.length\r\n\r\n\t\t# --- S is an array of sets of RuleEx objects\r\n\t\tRuleEx.resetNextID()   # reset IDs for RuleEx objects\r\n\r\n\t\tS = []\r\n\t\tinitRuleEx = RuleEx.get(@lRules[0], 0, 0)\r\n\t\tfor i from range(n)\r\n\t\t\tset = new Set()\r\n\t\t\tif (i == 0)\r\n\t\t\t\tset.add initRuleEx\r\n\t\t\tS.push set\r\n\r\n\t\tif debug\r\n\t\t\tyield \"START:\\n\" + @debugStr(undef, [initRuleEx])\r\n\r\n\t\tfor i from range(n)\r\n\t\t\tset = S[i]\r\n\t\t\tassert [\r\n\t\t\t\tdefined(set),\r\n\t\t\t\t(set instanceof Set),\r\n\t\t\t\t(set.size > 0),\r\n\t\t\t\t], \"Bad set #{i}: #{OL(set)}\"\r\n\r\n\t\t\tif debug\r\n\t\t\t\tLOG centered(i, 32, {char: '-'})\r\n\r\n\t\t\tfor xRule from S[i].values()\r\n\t\t\t\tnext = xRule.nextPart()\r\n\t\t\t\tswitch next.type\r\n\t\t\t\t\twhen \"nonterminal\"\r\n\t\t\t\t\t\tlNewRules = []\r\n\t\t\t\t\t\tlDupRules = []\r\n\t\t\t\t\t\tfor rule from @grammar.alternatives(next.value)\r\n\t\t\t\t\t\t\tnewRule = RuleEx.get(rule, i, 0)\r\n\t\t\t\t\t\t\tpre = S[i].size\r\n\t\t\t\t\t\t\tS[i].add newRule   # won't add dups\r\n\t\t\t\t\t\t\tisDup = (S[i].size == pre)\r\n\t\t\t\t\t\t\tif isDup\r\n\t\t\t\t\t\t\t\tlDupRules.push newRule\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\tlNewRules.push newRule\r\n\t\t\t\t\t\tif debug\r\n\t\t\t\t\t\t\tyield @debugStr(xRule, lNewRules, lDupRules)\r\n\t\t\t\t\twhen \"terminal\"\r\n\t\t\t\t\t\tif (next.value == str[i])\r\n\t\t\t\t\t\t\tnewRule = RuleEx.get(rule, i, xRule.pos+1)\r\n\t\t\t\t\t\t\tpre = S[i].size\r\n\t\t\t\t\t\t\tS[i+1].add xRule.getInc()\r\n\t\t\t\t\t\t\tisDup = (S[i].size == pre)\r\n\t\t\t\t\t\t\tif isDup\r\n\t\t\t\t\t\t\t\tlDupRules.push newRule\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\tlNewRules.push newRule\r\n\t\t\t\t\t\t\tyield @debugStr(xRule, lNewRules, lDupRules)\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tyield @debugStr(xRule, lNewRules)\r\n\t\t\t\t\twhen undef\r\n\t\t\t\t\t\t{head, src} = xRule\r\n\t\t\t\t\t\tfor xRuleFromSrc from S[src]\r\n\t\t\t\t\t\t\thPart = xRuleFromSrc.nextPart()\r\n\t\t\t\t\t\t\tif (hPart.type == 'nonterminal') \\\r\n\t\t\t\t\t\t\t\t\t&& (hPart.value == head)\r\n\t\t\t\t\t\t\t\tS[i].add xRule.getInc()\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tcroak \"Bad next type: #{OL(next)}\"\r\n\r\n\t\treturn\r\n\r\n\t# ..........................................................\r\n\r\n\tdebugStr: (srcRule, lNewRules=[], lDupRules=[]) ->\r\n\r\n\t\tif defined(srcRule)\r\n\t\t\tlLines = [srcRule.asString()]\r\n\t\telse\r\n\t\t\tlLines = []\r\n\r\n\t\tfor rule in lNewRules\r\n\t\t\tlLines.push \"   #{rule.asString()}\"\r\n\t\tfor rule in lDupRules\r\n\t\t\tlLines.push \"   #{rule.asString()} (DUP)\"\r\n\t\treturn lLines.join(\"\\n\")\r\n\r\n# ---------------------------------------------------------------------------\r\n#     Utility Functions\r\n# ---------------------------------------------------------------------------\r\n# --- returns [<set of nonterminals>, <set of terminals>]\r\n#     croaks if RHS of a rule has an undefined nonterminal\r\n\r\nexport checkAST = (hAST) ->\r\n\r\n\tassert [\r\n\t\tisHash(hAST),\r\n\t\t(hAST.type == 'grammar'),\r\n\t\thasKey(hAST, 'lRules'),\r\n\t\tisArray(hAST.lRules),\r\n\t\t], \"Bad AST: #{OL(hAST)}\"\r\n\r\n\tsetNonTerminals = new Set()\r\n\tfor hRule in hAST.lRules\r\n\t\tcheckRule(hRule)\r\n\t\tsetNonTerminals.add hRule.head\r\n\r\n\tsetTerminals = new Set()\r\n\tfor hRule,i in hAST.lRules\r\n\t\tfor item,j in hRule.lParts\r\n\t\t\tassert [\r\n\t\t\t\tisHash(item),\r\n\t\t\t\thasKey(item, 'type'),\r\n\t\t\t\t], \"Bad item #{i}/#{j}: #{OL(item)}\"\r\n\t\t\tif (item.type == 'terminal')\r\n\t\t\t\tsetTerminals.add item.value\r\n\t\t\telse if (item.type == 'nonterminal')\r\n\t\t\t\tassert setNonTerminals.has item.value\r\n\t\t\telse\r\n\t\t\t\tcroak \"Bad item #{i}/#{j}: #{OL(item)}\"\r\n\treturn [setNonTerminals, setTerminals]\r\n"
  ]
}